<h1 align="center" style="border-bottom: none">
    <a href="https://github.com/mx-ulises/certification-prep-cka-ckad" target="_blank">
        <img alt="" src="https://github.com/mx-ulises/certification-prep-cka-ckad/blob/main/assets/notes-logo.png?raw=true" style="border-radius: 50%; height: 100px;">
    </a>
    <br>
    CKA Lesson 3: Deploying Kubernetes Applications
</h1>
<h3 align="center" style="border-bottom: none">
    Notes by: <a href="https://github.com/mx-ulises" target="_blank">Ulises Martinez</a>
</h3>
<hr />

<p align="center">
    Auto-generated by the <a href="https://github.com/WhitneyLampkin/devscriber" target="_blank">DevScriber</a> command-line tool.
</p>

<div align="center">

![GitHub language count](https://img.shields.io/github/languages/count/mx-ulises/certification-prep-cka-ckad?label=Languages)
![GitHub contributors](https://img.shields.io/github/contributors/mx-ulises/certification-prep-cka-ckad?label=Contributors&color=yellow)
![GitHub repo size](https://img.shields.io/github/repo-size/mx-ulises/certification-prep-cka-ckad?label=Repo%20Size&color=teal)
![GitHub repo file count (file type)](https://img.shields.io/github/directory-file-count/mx-ulises/certification-prep-cka-ckad?label=Files&color=purple)

</div>

## Introduction

In this lesson we will review how to deploy applications using `Deployment`, `DaemonSet` and `StatefulSet`, all of them are used to run applications in different scenarios. We will also learn how to run individual `Pod` and managing their initialization and how to scale them. Finally we will use Sidecar container for log applications.

## Running scalable workloads

### ⭐ Deployments

The `Deployment` is the standard way for runninf containers in Kubernetes. They are responsable for starting pods in a scalable way. They uses `ReplicaSet` to manage scalability. Also, they support the `RollingUpdate` feature to allow zero-downtime application updates.

To start a `Deployment` in the imperative way, use `kubectl create deploy`.

### ⭐ DaemonSet

`DaemonSet` are used to run agents. It is a resource that start one application instance on each cluster node. There is no number of replica defined when create it. It is commonly used to start agents like `kube-proxy` that needs to run in all nodes.It can be used for user workloads, but it is rare. If the `DaemonSet` needs to run on control-plane nodes, a toleration must be configured to allow the node to run regarless of the control-plane taints. 

To start a `DaemonSet` are usually created using YAML spec files. To generate a `DaemonSet` YAML spec you can use `kubectl create deploy ... --dry-run=client -o yaml > myds.yaml`, and then edit the file to change or remove some of the details:

```
apiVersion: apps/v1
#kind: Deployment   //Change to DaemonSet
kind: DaemonSet
metadata:
  creationTimestamp: null
  labels:
    app: myds
  name: myds
spec:
  #replicas: 1     //Remove replicas
  selector:
    matchLabels:
      app: myds
  #strategy: {}   //Remove strategy
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: myds
    spec:
      containers:
      - image: nginx
        name: nginx
        resources: {}
status: {}
```

### ⭐ StatefulSet

Stateless application is an application that doesn't store any session data, and we can redirect traffic to another instance easily. For Stateful applications, we save the session data in persistent storage. Databases are an example of stateful applications.

The recommended Kubernetes resource to run a stateful application is the `StatefulSet`. It offers features that are needed by stateful applications:
- Provide guarantees about ordering and uniqueness of Pods
- Pods in `StatefulSet` are not interchangable: each Pod has a persistent identifier that it maintains while being rescheduled. The unique Pod identifier makes easier to match existing volumes to replaced Pods/

We should use `StatefulSet` when the application require one or more of the following:
- Stable and unique network identifiers
- Stable persistent storage
- Ordered, graceful deployment and scaling
- Ordered and automated rolling update

If none of these is needed, `Deployment` should be used instead.

Consider that Storage must be automatically provisioned by a prersistent volume provisioner. Pre-provisioning is challenging, as volumes need to be dynamically added when new Pods are scheduled. When a `StatefulSet` is deleted, associated volumes will not be deleted. a headless Service resource must be created in order to manage network identity of Pods. Pods are not guaranted to be stopped while deliting a `StatefulSet`, and it is recommended to scale-down to zero Pods before deleting the `StatefulSet`.

### ⭐ Scaling Applications

To manually scale an application running in a `Deployment`, `DaemonSet` or `StatefulSet`, you can use `kubectl scale`. Alternatively, a `HorizontalPodAutoscaler` (HPA) that can be configured with a maximum and minimum of instances. HPA is not covered in CKA exam.

## Pods and Containers

### ⭐ Running individual Pods

Running individual pods disadvantages:

- No workload protection (won't be rescheduled automatically if deleted)
- No load balancing
- No zero-downtime application update

Individual Pods are used for testing, troubleshooting and analyzing. In all other cases, it is better to use `Deployment`, `DaemonSet` or `StatefulSet`.

Use `kubectl run <name> --image=<image> -- <command> <args...>` to run an individual Pod.

### ⭐ Pod Initialization

Init containers are used when preparation is required before running the main container. They are part of the Pod. Init containers runs to completition, and once they finish, the main containers can be started.

Init containers are used where preliminary setup is required.

```
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: initexample
  name: initexample
spec:
  containers:
  - image: ngnix
    name: main
    resources: {}
  # Start: Init containers
  initContainers:
  - args:
    - sleep
    - "3600"
    image: busybox
    name: initexample
    resources: {}
  # End: Init containers
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
```

### ⭐ Sidecar Containers

Pods should be created for each specific task, running single-container Pods is the standard. In some cases, additional containers are needed to modify or present data generated by the main container. Some specific usecases are:
- Sidecar: Provides additional functionality to the main container
- Ambassador: Is used as a proxy to connect containers externally
- Adapter: Is used to standarize or normalize main container output

To run multi-container pods you also need couse shared storage, such as Pod Volumes. The Pod Volume may use PersistentVolumeClaim (PVC) to refer to a PersistentVolume (PV), but may also directly refer to the required storage. By ussing the shared storage, the main container can write to it, and the helper Pod will pick-up information there.

```
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: sidecarexample
  name: sidecarexample
spec:
  containers:
  - name: nginx-container
    image: nginx
    # Start: Main container reading from shared storage
    volumeMounts:
    - name: shared-data
      mountPath: /usr/share/nginx/html
    # End: Main container reading from shared storage
  # Start: Sidecar container writing to the shared storage
  - name: sidecarexample
    args:
    - /bin/sh
    - -c
    - echo hello world from sidecar > /messages/index.html && sleep 600
    image: busybox
    resources: {}
    volumeMounts:
    - name: shared-data
      mountPath: /messages
  # End: Sidecar container writing to the shared storage
  # Start: Volume to share data across containers
  volumes:
  - name: shared-data
    emptyDir: {}
  # End: Volume to share data across containers
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
```

<p align="center" style="border-bottom: none; margin-top: 50px;">
    <a href="https://github.com/mx-ulises/certification-prep-cka-ckad" target="_blank">
        <img alt="" src="https://github.com/mx-ulises/certification-prep-cka-ckad/blob/main/assets/notes-logo.png?raw=true" style="border-radius: 50%; height: 100px;">
    </a>
</p>
