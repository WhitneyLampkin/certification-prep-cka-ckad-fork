<h1 align="center" style="border-bottom: none">
    <a href="https://github.com/mx-ulises/certification-prep-cka-ckad" target="_blank">
        <img alt="" src="https://github.com/mx-ulises/certification-prep-cka-ckad/blob/main/assets/notes-logo.png?raw=true" style="border-radius: 50%; height: 100px;">
    </a>
    <br>
    CKAD Lesson 6: Managing Pod Advanced Features
</h1>
<h3 align="center" style="border-bottom: none">
    Notes by: <a href="https://github.com/mx-ulises" target="_blank">Ulises Martinez</a>
</h3>
<hr />

<p align="center">
    Auto-generated by the <a href="https://github.com/WhitneyLampkin/devscriber" target="_blank">DevScriber</a> command-line tool.
</p>

<div align="center">

![GitHub language count](https://img.shields.io/github/languages/count/mx-ulises/certification-prep-cka-ckad?label=Languages)
![GitHub contributors](https://img.shields.io/github/contributors/mx-ulises/certification-prep-cka-ckad?label=Contributors&color=yellow)
![GitHub repo size](https://img.shields.io/github/repo-size/mx-ulises/certification-prep-cka-ckad?label=Repo%20Size&color=teal)
![GitHub repo file count (file type)](https://img.shields.io/github/directory-file-count/mx-ulises/certification-prep-cka-ckad?label=Files&color=purple)

</div>

## Introduction

In this lesson, we will learn about the advanced features of Pods, including how to explore a Pod's state with `kubectl describe`, investigate Pod logs for troubleshooting, utilize port forwarding to access Pods, and configure basic security settings with `SecurityContext`.

Additionally, in addition to advanced features of Pods, this lesson will also cover how to manage Jobs, Cron Jobs, and how to handle resource limits, quotas, and cleanup.

## Pod Troubleshoothing

There are several techniques for troubleshooting a Pod in Kubernetes, such as describing a Pod to retrieve details about its state, connecting to a Pod and running commands inside to investigate what happened, or reviewing the logs using `kubectl`.

| Troubleshooting Technique | Kubectl Command |
| - | - |
| Pod State | `kubectl describe` |
| Resource Field Description | `kubectl explain pods.spec.fieldName` |
| Connect to Pod | `kubectl exec -it PodName -- sh` |
| Pod Logs | `kubectl logs` |
| Port Forwarding | `kubectl port-forward MyPod LocalPort:PodPort` |


### ⭐ Pod State

The command `kubectl describe` allows you to explore resources created in Kubernetes. When you create a resource, such as a Pod, many parameters are defined as defaults. You can view these parameters with the `describe` command in a human-readable way, as well as in YAML, JSON, and other formats. Details include events, which are the most important events that have occurred in the Pod.

The Kubernetes Official documentation provides details about several parameters of different resources. You can also use the command `kubectl explain pods.spec.fieldName` to get a description of what a field does.

### ⭐ Connect to the Pod

Another way to troubleshoot a Pod is to connect to it and run commands on the primary container. To do this, you can typically use `kubectl exec -it PodName -- sh`. This command will initiate an interactive shell session with the main container in the Pod, allowing you to execute commands available within the container for further investigation.

This technique assumes that you are familiar with the image of the container you are accessing, including the available commands, the application inside, and the location of the logs, among other things.

### ⭐ Pod Logs

The Pod's entrypoint application does not connect to `STDOUT` as this is collected by the Kubernetes cluster. The command `kubectl logs` helps in accessing these logs and their outputs. Usually, you will want to begin by checking the status of the Pod using `kubectl get pods` or `kubectl describe` to obtain as many details as possible. If the Pod's main application exhibits a non-zero exit code, along with suspicious last states and reasons, it is advisable to access the logs.

### ⭐ Pod's Port Forwarding

Verifying port access to Pods is also important for troubleshooting Pods. Port forwarding is a method to access a Pod for troubleshooting purposes. A straightforward approach is to use the `kubectl port-forward MyPod LocalPort:PodPort` command to expose a Pod's port on a local machine. This is intended for testing and troubleshooting purposes since these ports are typically exposed through services and ingress configurations.

## Security Settings with Security Context

Security Context is used to define privilege and access control in Pods. It includes:

 - Discretionary Access control to set permissions to access objects.
 - Using Security Enhanced Linux (SELinux) or AppArmor to apply security labels.
 - Running as a privileged or unprivileged user.
 - Using Linux capabilities.
 - Allowing Privilege Escalation, which controls if a process can gain more privileges than its parent.

The `SecurityContext` can be applied to the Pod or to a container. When `SecurityContext` prevents a Pod from running successfully, an event will be logged and you can review it with `kubectl describe` and analyze it with `kubectl logs` on failing Pods.

| Command | Description |
| ------- | ----------- |
| k apply -f [SC_YAML_FILE] | Creates or updates a Security Context resource. |
| k exec -it [SC_POD_NAME] -- sh | Interact with the pod that has a Security Context defined. |

| Command | Description |
| ------- | ----------- |
| ps | Shows all processes and the USER running them. |

## Jobs and Cron Jobs

Pods are expected to run indefinitely unless they encounter a failure or you manually stop them; their execution is not expected to terminate. In contrast, Jobs are designed for one-shot tasks, such as backups, functions, or batch processing. Jobs are used to execute a task a specific number of times, while Cron Jobs are used for tasks that need to run on a regular schedule.

### ⭐ Jobs

When you run a Job, it will create a Pod, and the Pod will continue running until completion, at which point it will be marked as completed. You can use `spec.ttlSecondsAfterFinished` to automatically clean up completed jobs. There are three types of jobs specified by the `completions` and `parallelism` parameters:

 - **Non-parallel Job**: One Pod is started unless the Pod fails. Configuration is `completions=1` and `parallelism=1`.
 - **Parallel Job with a fixed completion count**: The Job is considered completed after successfully running as many times as specified by `completions`. Configuration is `completions=n` and `parallelism=m`.
 - **Parallel Job with a worker queue**: Multiple Jobs are started, and when one successfully completes, the entire Job is considered completed. Configuration is `completions=1` and `parallelism=n`.

| Command | Description |
|-|-|
| `kubectl create job JobName --image=ImageName -- Command` | Create a Kubernetes Job named `JobName` using the specified container image (`ImageName`) and command (`Command`). |
| `kubectl get jobs` | List all the Jobs running in the Kubernetes cluster. |
| `kubectl delete job JobName` | Delete a specific Job named `JobName` from the cluster. |

To modify the job, you can do so by editing the Job's YAML file. See the example below:

```
kubectl create job myjob --image=busybox --dry-run=client -o yaml -- date
```

This will output this Job YAML:

```
apiVersion: batch/v1
kind: Job
metadata:
  creationTimestamp: null
  name: myjob
spec:
  template:
    metadata:
      creationTimestamp: null
    spec:
      containers:
      - command:
        - date
        image: busybox
        name: myjob
        resources: {}
      restartPolicy: Never
status: {}
```

You can add the parameters for `completions`, `parallelism`, and `ttlSecondsAfterFinished` within the `spec` section here:

```
apiVersion: batch/v1
kind: Job
metadata:
  creationTimestamp: null
  name: myjob
spec:
  completions: 3
  parallelism: 2
  ttlSecondsAfterFinished: 60
  template:
    metadata:
      creationTimestamp: null
    spec:
      containers:
      - command:
        - date
        image: busybox
        name: myjob
        resources: {}
      restartPolicy: Never
status: {}
```

### ⭐ Cron Jobs

Cron Jobs are higher-level Kubernetes objects that manage Jobs. Cron Jobs schedule Jobs, and when the Jobs run, they initiate Pods.

| Command | Description |
|-|-|
| `kubectl create cronjob MyCronJob --image=ImageName --schedule=Schedule -- Command` | Create a Kubernetes CronJob named `MyCronJob` using the specified container image (`ImageName`), schedule (`Schedule`), and command (`Command`). |
| `kubectl create job MyJob --from=cronjob/MyCronJob` | Create a Job named `MyJob` using the settings from the `MyCronJob` CronJob. |
| `kubectl get cronjobs`  List all the CronJobs in the Kubernetes cluster. |
| `kubectl logs MyCronJob-xxx-yyy` | View the logs of a specific CronJob instance, identified by `MyCronJob-xxx-yyy`. |
| `kubectl delete cronjob MyCronJob` | Delete the CronJob named `MyCronJob` from the cluster. |

## Managing Resources

### ⭐ Resource Limits

Resource `requests` and `limits` can be set as application properties. By default, Pods will use as much CPU and memory as they need to perform their tasks. To manage resource utilization, you can set `limits` within `pod.spec.containers.resources`. Here is an example of a Pod YAML file with resources configured.

```
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: mynginx
  name: mynginx
spec:
  containers:
  - image: nginx
    name: mynginx
    resources:
      requests:
        cpu: "0.25"
        memory: 250Mi
      limits:
        cpu: "0.5"
        memory: 500Mi
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
```

To apply resource limits to a running application, you can use `kubectl set resources`.

A `request` is an initial request for resources for the Pod. A `limit` defines an upper threshold of resources that a Pod can utilize. CPU resources are expressed in millicores (1/1000 of a CPU core), while memory is usually expressed in Megabytes (Mi). When being scheduled, the kube-scheduler ensures that the node running the Pods has all requested resources available. If a Pod with resource limits cannot be scheduled, it will display a status of `Pending`, and you will see in the events that it cannot find a node with available resources. A Pod that is too strict with memory and runs out of memory will be in the `Terminated` status with an `OOMKilled` reason.

### ⭐ Quota

Quotas are restrictions applied to Namespaces. If quotas are set on a Namespace, applications started in that Namespace must have resource requests and limits specified.

To create a quota, you can use the following command: `kubectl create quota myquota -n restricted --hard=cpu=2,memory=1G,pods=3`.

You can also utilize a YAML file:

```
apiVersion: v1
kind: Namespace
metadata:
  creationTimestamp: null
  name: restricted
spec: {}
status: {}
---
apiVersion: v1
kind: ResourceQuota
metadata:
  creationTimestamp: null
  name: myquota
  namespace: restricted
spec:
  hard:
    memory: 1G
    cpu: "2"
    pods: "3"
status: {}
```

Quota restrictions will be visible when you describe the Namespace using `kubectl describe namespace restricted`:

```
Name:         restricted
Labels:       kubernetes.io/metadata.name=restricted
Annotations:  <none>
Status:       Active

Resource Quotas
  Name:     myquota
  Resource  Used  Hard
  --------  ---   ---
  cpu       0     2
  memory    0     1G
  pods      0     3
```

Resource creation will fail in the following scenarios:
 - If a resource without resource limitations is created in a namespace with Quota.
 - If a resource with resource limitations is created and it exceeds the Quota.

## Cleaning up Resources

Resources are not automatically cleaned up. Some Kubernetes resources have options for automatic cleanup when they are no longer used, but periodic manual cleanup may be required. If a Pod is managed by another resource such as a Deployment or a Job, the resource should be removed, and not the Pod directly. Forcing resource deletion might lead to the resources being in an unmanageable state, which is not recommended, as troubleshooting will become complex.

| Command | Description |
|-|-|
| `kubectl delete all --all` | Delete all resources in the current namespace. |
| `kubectl delete all --all --force --grace-period=-1` | Forcefully and immediately delete all resources in the current namespace, bypassing any graceful termination periods. ***Note: Running this is not recommended, as it can be dangerous for your environment.***|

<p align="center" style="border-bottom: none; margin-top: 50px;">
    <a href="https://github.com/mx-ulises/certification-prep-cka-ckad" target="_blank">
        <img alt="" src="https://github.com/mx-ulises/certification-prep-cka-ckad/blob/main/assets/notes-logo.png?raw=true" style="border-radius: 50%; height: 100px;">
    </a>
</p>
