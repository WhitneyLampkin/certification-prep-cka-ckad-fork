<h1 align="center" style="border-bottom: none">
    <a href="https://github.com/mx-ulises/certification-prep-cka-ckad" target="_blank">
        <img alt="" src="https://github.com/mx-ulises/certification-prep-cka-ckad/blob/main/assets/notes-logo.png?raw=true" style="border-radius: 50%; height: 100px;">
    </a>
    <br>
    CKAD Lesson 5: Managing Pod Basic Features
</h1>
<h3 align="center" style="border-bottom: none">
    Notes by: <a href="https://github.com/mx-ulises" target="_blank">Ulises Martinez</a>
</h3>
<hr />

<p align="center">
    Auto-generated by the <a href="https://github.com/WhitneyLampkin/devscriber" target="_blank">DevScriber</a> command-line tool.
</p>

<div align="center">

![GitHub language count](https://img.shields.io/github/languages/count/mx-ulises/certification-prep-cka-ckad?label=Languages)
![GitHub contributors](https://img.shields.io/github/contributors/mx-ulises/certification-prep-cka-ckad?label=Contributors&color=yellow)
![GitHub repo size](https://img.shields.io/github/repo-size/mx-ulises/certification-prep-cka-ckad?label=Repo%20Size&color=teal)
![GitHub repo file count (file type)](https://img.shields.io/github/directory-file-count/mx-ulises/certification-prep-cka-ckad?label=Files&color=purple)

</div>

## Introduction

In this lesson, we are going to review the basics of Pods and their containers. We will also learn how to set up multi-container Pods and init containers. Additionally, we will review how to manage resources using YAML files, focusing for now only on Pods, and learn some basics about Namespaces.

## What is a Pod

At a high level, Pods serve as abstractions of servers. You can run multiple services within a server, and they will share some resources, such as IP and namespace. Within the Pod, you have containers, which are the means by which you run services within this abstraction. These services are loaded from the images within your containers.

Kubernetes doesn't manage containers directly; it does so through Pods. Typically, you manage Pods through other Kubernetes resources, such as Deployments. While you can run standalone Pods that are not managed by another higher-level resource, keep in mind that Pods won't be automatically rescheduled if they are deleted. If you need to make updates to a Pod, you might experience downtime if you didn't manually create replicas of it. Additionally, standalone Pods cannot scale with configuration changes.

Below is a list of commands for managing Pods:

| Command | Description |
|-|-|
| `kubectl run PodName --image=ImageName` | Creates a new Pod with the specified name and container image. |
| `kubectl get pods` | Lists all the Pods currently running in the cluster. |
| `kubectl describe pod` | Displays detailed information about a specific Pod, including its configuration and current status. |

## YAML Files

Creating resources in Kubernetes can happen in two ways:
 - ***Imperative***: You can use `kubectl` to manage the resources you need in the order you require with `create` or `delete` commands.
 - ***Declarative***: You can define what resources you want a create in a configuration file and then use `kubectl` to apply that configuration to the cluster. This is the preferred way in a production environment.

[YAML](https://en.wikipedia.org/wiki/YAML) files are human-readable configuration files used by DevOps professionals to manage objects and resources in Kubernetes and other Cloud Native environments. You define your resources and configurations in YAML files and store them in source control systems like [Git](https://git-scm.com/). This enables you to easily track changes, a practice known as Infrastructure as Code ([IaC](https://en.wikipedia.org/wiki/Infrastructure_as_code)). To identify relationships between properties within the YAML file, it uses indentation.

Kubernetes YAML files contain the following fields:

| Field | Description |
|-|-|
| `apiVersion` | Specifies the API version of Kubernetes that the resource adheres to. |
| `kind` | Defines the type of resource being described in the YAML file, such as Pod, Service, or Deployment. |
| `metadata` | Contains metadata about the resource, including its name, namespace, and labels. |
| `spec` | Contains the specification or configuration details for the resource, defining how it should behave and its desired state. |

Pod specifications contain the following fields:

| Field | Description |
|-|-|
| `name` | Specifies the name of the Pod, which is used to identify it within the Kubernetes cluster. |
| `image` | Specifies the container image that should be run in the Pod, typically containing the application or service.  |
| `command` | Defines the primary command to be executed when the container starts. |
| `args` | Specifies additional arguments to be passed to the command defined in the `command` field when the container starts. |
| `env` | Contains environment variables that can be set within the container to configure its behavior or parameters. |

The best way to create Kubernetes YAML files is by generating them. Two popular options for generating Kubernetes YAML files are:

 - Use examples from reputable sources, such as [the Official Kubernetes Documentation](https://kubernetes.io/docs/home/).
 - Generate samples using the `--dry-run=client -o yaml` optional arguments within `kubectl` commands.

By running `kubectl run MyNgnix --image=ngnix --dry-run=client -o yaml` you can generate the following Pod YAML file:

```
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: mynginx
  name: mynginx
spec:
  containers:
  - image: nginx
    name: mynginx
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
```

You can manage Kubernetes resources defined in YAML files with the following list of `kubectl` commands using the optional argument `-f resource.yaml`:

| Command | Description |
|-|-|
| `kubectl create -f resource.yaml` | Creates Kubernetes resources defined in a YAML file, and it will fail if the resource already exists. |
| `kubectl apply -f resource.yaml` | Creates or updates Kubernetes resources defined in a YAML file, ensuring the desired state is achieved. |
| `kubectl delete -f resource.yaml` | Deletes Kubernetes resources defined in a YAML file, effectively removing them from the cluster. |
| `kubectl replace -f resource.yaml` | Deletes and then recreates Kubernetes resources defined in a YAML file, allowing for complete resource replacement. |

## Multi-container Pods and initContainers

Single-container Pods are the standard and the earlier way to maintain Pods because they maintain a higher level of isolation. One issue with having multiple containers in a pod is that if you need to update a container within a pod, you need to take down the entire Pod. However, there are scenarios where you need multiple containers in your Pod, specifically when you need to enhance the functionality of your service independently of your main service. Some typical multi-container Pod scenarios include:

 - **Sidecar**: Enhancing the main application with standard capabilities, such as log collectors, monitoring, etc., which are run by other containers. Typically, the sidecar communicates with other containers using volumes.
 - **Ambassador**: A container that takes on responsibilities such as load balancing within the Pod, reverse proxy, and connectivity with external clients.
 - **Adapter**: A container used to adapt to data and traffic patterns in other applications when you cannot directly change the code in the main container.

All these patterns are not defined as Kubernetes resources; they are simply regular multi-container pods. Here's an example of a multi-container Pod definition in a YAML file:

```
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: mynginx
  name: mynginx
spec:
  volumes:
    - name: shared-data
      emptyDir: {}
  containers:
  - image: nginx
    name: mynginx
    volumeMounts:
      - name: shared-data
        mountPath: /usr/share/nginx/html
  - name: ubuntu-container
    image: ubuntu
    volumeMounts:
    - name: shared-data
      mountPath: /pod-data
    command: ["/bin/sh"]
    args: ["-c", "while true; do date >> /pod-data/index.html; sleep 10; done"]
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
```

### ⭐ Init Containers

Init containers are a special case of multi-container Pods, and they are represented in Kubernetes. These containers run before the main container and are used to perform specific tasks that the main container depends on before it starts.

To add an init container to a Pod, include it within the Pod spec as an `initContainer`. Here is an example of a Pod with an init container:

```
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: mynginx
  name: mynginx
spec:
  volumes:
    - name: shared-data
      emptyDir: {}
  initContainers:
    - name: ubuntu-container
      image: ubuntu
      volumeMounts:
        - name: shared-data
          mountPath: /pod-data
      command: ["/bin/sh"]
      args: ["-c", "date >> /pod-data/index.html"]
  containers:
    - image: nginx
      name: mynginx
      volumeMounts:
        - name: shared-data
          mountPath: /usr/share/nginx/html
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
```

## Namespaces

Namespaces are used to ensure resource isolation, strictly separating Kubernetes resources. Kubernetes namespaces can be employed to apply security-related settings, such as Role-Based Access Control (RBAC), to prevent unauthorized access to resources, and quota settings to limit the amount of resources within a namespace.

To manage and acces namespaces, use the following flags and commands:

| Flag | Description |
|-|-|
| `-n namespace` | Specifies the namespace in which the `kubectl` command should operate, allowing you to target resources within that specific namespace. |
| `--all-namespaces` or `-A` | Indicates that the `kubectl` command should operate across all namespaces in the Kubernetes cluster, providing a global scope for resource operations. |
| `kubectl create namespace MyNamespace` | Creates a new Kubernetes namespace with the specified name. |

In YAML files, the resource's namespace is specified within the `metadata` configuration as follows:

```
apiVersion: v1
kind: Pod
metadata:
  ...
  name: MyNgnix
  namespace: default
spec:
   ...
```

<p align="center" style="border-bottom: none; margin-top: 50px;">
    <a href="https://github.com/mx-ulises/certification-prep-cka-ckad" target="_blank">
        <img alt="" src="https://github.com/mx-ulises/certification-prep-cka-ckad/blob/main/assets/notes-logo.png?raw=true" style="border-radius: 50%; height: 100px;">
    </a>
</p>
