<h1 align="center" style="border-bottom: none">
    <a href="https://github.com/mx-ulises/certification-prep-cka-ckad" target="_blank">
        <img alt="" src="https://github.com/mx-ulises/certification-prep-cka-ckad/blob/main/assets/notes-logo.png?raw=true" style="border-radius: 50%; height: 100px;">
    </a>
    <br>
    Istio Topic 3: Fault Injection
</h1>
<h3 align="center" style="border-bottom: none">
    Notes by: <a href="https://github.com/mx-ulises" target="_blank">Ulises Martinez</a>
</h3>
<hr />

<p align="center">
    Auto-generated by the <a href="https://github.com/WhitneyLampkin/devscriber" target="_blank">DevScriber</a> command-line tool.
</p>

<div align="center">

![GitHub language count](https://img.shields.io/github/languages/count/mx-ulises/certification-prep-cka-ckad?label=Languages)
![GitHub contributors](https://img.shields.io/github/contributors/mx-ulises/certification-prep-cka-ckad?label=Contributors&color=yellow)
![GitHub repo size](https://img.shields.io/github/repo-size/mx-ulises/certification-prep-cka-ckad?label=Repo%20Size&color=teal)
![GitHub repo file count (file type)](https://img.shields.io/github/directory-file-count/mx-ulises/certification-prep-cka-ckad?label=Files&color=purple)

</div>

## Introduction

These notes cover the topic on how we can do fault injection on services part of the Istio's service registry using `DestinationRule` and `VirtualService`. This enables things such as resilency testing. Relevant documentations includes the following:

 * [Documentation](https://istio.io/latest/docs/) > [Tasks](https://istio.io/latest/docs/tasks/) > [Traffic Management](https://istio.io/latest/docs/tasks/traffic-management/) > [Fault Injection](https://istio.io/latest/docs/tasks/traffic-management/fault-injection/)
 * [Documentation](https://istio.io/latest/docs/) > [Reference](https://istio.io/latest/docs/reference/) > [Configuration](https://istio.io/latest/docs/reference/config/) > [Traffic Management](https://istio.io/latest/docs/reference/config/networking/) > [Destination Rule](https://istio.io/latest/docs/reference/config/networking/destination-rule/)
 * [Documentation](https://istio.io/latest/docs/) > [Reference](https://istio.io/latest/docs/reference/) > [Configuration](https://istio.io/latest/docs/reference/config/) > [Traffic Management](https://istio.io/latest/docs/reference/config/networking/) > [Virtual Service](https://istio.io/latest/docs/reference/config/networking/virtual-service/)


## Deploy Pre-Requisites

For this task, we will deploy a `Deployment` (`nginx-app-v1`) that has the `app` label (`nginx-app`) and the `version` label (`v1` and `v2`). When we hit the port `80` on these deployments, this will display a message with the `Pod` name (that includes the version as well):

```
Welcome to: nginx-app-v1-55cbcdd84-hvzph
```

Additionally, we create a `Service` with the selector `app=nginx-app`, meaning that the endpoints are all `Pod` in the deployment.

All these resources are created in a the `fault-injection` namespace that is created as well by this spec.

Apply the file [nginx-app.yaml](nginx-app.yaml) to deploy all the resources:

```
kubectl apply -f nginx-app.yaml
```

You should see following resources:

```
kubectl get all -n fault-injection

NAME                               READY   STATUS    RESTARTS   AGE
pod/nginx-app-v1-55cbcdd84-hvzph   1/2     Running   0          5s

NAME                TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
service/nginx-app   ClusterIP   10.96.43.219   <none>        80/TCP    5s

NAME                           READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/nginx-app-v1   0/1     1            0           5s

NAME                                     DESIRED   CURRENT   READY   AGE
replicaset.apps/nginx-app-v1-55cbcdd84   1         1         0       5s
```

## Accessing the Service

You can access your service from another Pod. For this purpose, we create an auxiliar sleep nginx Pod:

```
kubectl run sleep --image=nginx -n fault-injection -- sleep 3600
```

And then you can run curl on it:

```
kubectl exec sleep -c sleep -n fault-injection -- curl nginx-app 2> /dev/null
# Welcome to: nginx-app-v1-55cbcdd84-hvzph
```

## Defining `DestinationRule` with subsets

A `DestinationRule` is a resource that help to configure policies once traffic arrived to the service. Different configurations can be added here such as Load Balancing policies. In this case we are adding a rule to define `subsets` in the destination based on the labels of the `Pod` selected by the service.

In the file [nginx-app-dr.yaml](nginx-app-dr) we are indicating that the `nginx-app` service we previously created will have a subset `v1` that will select the `Pod` with label `version=v1`.

```
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: nginx-app-dr
  namespace: fault-injection
spec:
  host: nginx-app
  subsets:
  - name: v1
    labels:
      version: v1
```

As we apply this policy, we won't have any effect yet in the routing as we are just defining names for groups of `Pod` that the `Service` can recognize, but these `subsets` can be used later by the `VirtualService` to route the requests.

```
kubectl apply -f nginx-app-dr.yaml
```

## Defining `VirtualService` to inject Delay

Fault injection configurations happens here. We create following `VirtualService` that will default all traffic comming to `nginx-app` to the `Pod` in subset `v1` of service `nginx-app` with no fault injection, and we add a match for the header `route-to-delay: true` to insert a delay of `7s` in 100% of the requests.. This definiton is in file [nginx-app-vs-delay-only.yaml](nginx-app-vs-delay-only.yaml):

```
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: nginx-app-vs
  namespace: fault-injection
spec:
  hosts:
  - nginx-app
  http:
  - match:
    - headers:
        route-to-delay:
          exact: "true"
    route:
    - destination:
        host: nginx-app
        subset: v1
    fault:
      delay:
        fixedDelay: 7s
        percentage:
          value: 100
  - route:
    - destination:
        host: nginx-app
        subset: v1
```

We can apply and test our delay:

```
# Deploy the VirtualService with fault injection
kubectl apply -f nginx-app-vs-delay-only.yaml

# Test default rule with no delay
kubectl exec sleep -c sleep -n fault-injection -- curl nginx-app -v
```

You should get an output like this almost instantly:

```
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying 10.96.43.219:80...
* Connected to nginx-app (10.96.43.219) port 80 (#0)
> GET / HTTP/1.1
> Host: nginx-app
> User-Agent: curl/7.88.1
> Accept: */*
>
< HTTP/1.1 200 OK
< server: envoy
< date: Thu, 04 Apr 2024 20:00:19 GMT
< content-type: text/html
< content-length: 41
< last-modified: Thu, 04 Apr 2024 19:44:02 GMT
< etag: "660f0302-29"
< accept-ranges: bytes
< x-envoy-upstream-service-time: 1
<
{ [41 bytes data]
100    41  100    41    0     0  12488      0 --:--:-- --:--:-- --:--:-- 13666
* Connection #0 to host nginx-app left intact
Welcome to: nginx-app-v1-55cbcdd84-hvzph
```

To add the delay, run with the `route-to-delay: true` header:

```
kubectl exec sleep -c sleep -n fault-injection -- curl nginx-app -v -H "route-to-delay: true"
```

And you will get an output like this indicating the elapsed time around 7 seconds:

```
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying 10.96.43.219:80...
* Connected to nginx-app (10.96.43.219) port 80 (#0)
> GET / HTTP/1.1
> Host: nginx-app
> User-Agent: curl/7.88.1
> Accept: */*
> route-to-delay: true
>
  0     0    0     0    0     0      0      0 --:--:--  0:00:06 --:--:--     0< HTTP/1.1 200 OK
< server: envoy
< date: Thu, 04 Apr 2024 20:02:38 GMT
< content-type: text/html
< content-length: 41
< last-modified: Thu, 04 Apr 2024 19:44:02 GMT
< etag: "660f0302-29"
< accept-ranges: bytes
< x-envoy-upstream-service-time: 10
<
{ [41 bytes data]
100    41  100    41    0     0      5      0  0:00:08  0:00:07  0:00:01    10
* Connection #0 to host nginx-app left intact
Welcome to: nginx-app-v1-55cbcdd84-hvzph
```

## Defining `VirtualService` to inject Abort

Now, instead of adding a delay, we want to fail the request. We create following `VirtualService` that will default all traffic comming to `nginx-app` to the `Pod` in subset `v1` of service `nginx-app` with no fault injection, and we add a match for the header `route-to-abort: true` to insert an abort with 500 error code in 100% of the requests.. This definiton is in file [nginx-app-vs-abort-only.yaml](nginx-app-vs-abort-only.yaml):

```
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: nginx-app-vs
  namespace: fault-injection
spec:
  hosts:
  - nginx-app
  http:
  - match:
    - headers:
        route-to-abort:
          exact: "true"
    route:
    - destination:
        host: nginx-app
        subset: v1
    fault:
      abort:
        httpStatus: 500
        percentage:
          value: 100
  - route:
    - destination:
        host: nginx-app
        subset: v1
```

We can apply and test our delay:

```
# Deploy the VirtualService with fault injection
kubectl apply -f nginx-app-vs-abort-only.yaml

# Test default rule with no abort
kubectl exec sleep -c sleep -n fault-injection -- curl nginx-app -v
```

You should get an output like this almost instantly:

```
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying 10.96.43.219:80...
* Connected to nginx-app (10.96.43.219) port 80 (#0)
> GET / HTTP/1.1
> Host: nginx-app
> User-Agent: curl/7.88.1
> Accept: */*
>
< HTTP/1.1 200 OK
< server: envoy
< date: Thu, 04 Apr 2024 20:00:19 GMT
< content-type: text/html
< content-length: 41
< last-modified: Thu, 04 Apr 2024 19:44:02 GMT
< etag: "660f0302-29"
< accept-ranges: bytes
< x-envoy-upstream-service-time: 1
<
{ [41 bytes data]
100    41  100    41    0     0  12488      0 --:--:-- --:--:-- --:--:-- 13666
* Connection #0 to host nginx-app left intact
Welcome to: nginx-app-v1-55cbcdd84-hvzph
```

To add the delay, run with the `route-to-abort: true` header:

```
kubectl exec sleep -c sleep -n fault-injection -- curl nginx-app -v -H "route-to-abort: true"
```

And you will get an output like this indicating the abort error as `500 Internal Server Error`:

```
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying 10.96.43.219:80...
* Connected to nginx-app (10.96.43.219) port 80 (#0)
> GET / HTTP/1.1
> Host: nginx-app
> User-Agent: curl/7.88.1
> Accept: */*
> route-to-abort: true
>
fault filter abort< HTTP/1.1 500 Internal Server Error
< content-length: 18
< content-type: text/plain
< date: Thu, 04 Apr 2024 20:06:28 GMT
< server: envoy
<
{ [18 bytes data]
100    18  100    18    0     0    585      0 --:--:-- --:--:-- --:--:--   600
* Connection #0 to host nginx-app left intact
```

## Defining `VirtualService` to inject both types of errors

We can include both type of errors in the same `VirtualService`. We need to have two different matching rules (in this case, using a different header), and each of them will have a different type of error. The file [nginx-app-vs-fault.yaml](nginx-app-vs-fault.yaml) includes both of them:

```
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: nginx-app-vs
  namespace: fault-injection
spec:
  hosts:
  - nginx-app
  http:
  - match:
    - headers:
        route-to-delay:
          exact: "true"
    route:
    - destination:
        host: nginx-app
        subset: v1
    fault:
      delay:
        fixedDelay: 7s
        percentage:
          value: 100
  - match:
    - headers:
        route-to-abort:
          exact: "true"
    route:
    - destination:
        host: nginx-app
        subset: v1
    fault:
      abort:
        httpStatus: 500
        percentage:
          value: 100
  - route:
    - destination:
        host: nginx-app
        subset: v1
```

After we apply the manifest, we can use both type of testing on delay, abort and default behaviour:

```
# Apply the manifest
kubectl apply -f nginx-app-vs-fault.yaml

# Test Delay
kubectl exec sleep -c sleep -n fault-injection -- curl nginx-app -v -H "route-to-delay: true"

# Test Abort
kubectl exec sleep -c sleep -n fault-injection -- curl nginx-app -v -H "route-to-abort: true"

# Test default behaviour
kubectl exec sleep -c sleep -n fault-injection -- curl nginx-app -v
```


<p align="center" style="border-bottom: none; margin-top: 50px;">
    <a href="https://github.com/mx-ulises/certification-prep-cka-ckad" target="_blank">
        <img alt="" src="https://github.com/mx-ulises/certification-prep-cka-ckad/blob/main/assets/notes-logo.png?raw=true" style="border-radius: 50%; height: 100px;">
    </a>
</p>
